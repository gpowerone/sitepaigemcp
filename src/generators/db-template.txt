/*
Sitepaige v1.0.0
Database abstraction layer for multiple database support
WARNING: This file is automatically generated and should not be modified.
*/

import * as path from 'path';
import * as fs from 'fs';

interface ModelField {
  name: string;
  datatype: string;
  datatypesize: string | null;
  required: string;
  key: string | null;
  default?: any;
}

interface Model {
  id: string;
  name: string;
  fields: ModelField[];
  data_is_user_specific?: string; // Added for user-specific data
}

// Database client type that's compatible across all database types
export type DatabaseClient = any;

// Database type enum
export type DatabaseType = 'sqlite' | 'postgres' | 'mysql';

// Database configuration
export interface DatabaseConfig {
  type: DatabaseType;
  connectionString?: string; // For postgres/mysql
  host?: string;
  port?: number;
  user?: string;
  password?: string;
  database?: string;
  sqliteDir?: string; // For sqlite
  efsMountPath?: string; // For production sqlite
  ssl?: {
    rejectUnauthorized?: boolean;
    require?: boolean;
    ca?: string;
    cert?: string;
    key?: string;
  }; // SSL configuration for postgres/mysql
}

// Get database configuration from environment
export function getDatabaseConfig(): DatabaseConfig {
  const dbType = (process.env.DATABASE_TYPE || 'postgres').toLowerCase() as DatabaseType;
  
  switch (dbType) {
    case 'postgres':
      return {
        type: 'postgres',
        connectionString: process.env.DATABASE_URL || process.env.POSTGRES_URL,
        host: process.env.DB_HOST || process.env.POSTGRES_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || process.env.POSTGRES_PORT || '5432'),
        user: process.env.DB_USER || process.env.POSTGRES_USER || 'postgres',
        password: process.env.DB_PASSWORD || process.env.POSTGRES_PASSWORD,
        database: process.env.DB_NAME || process.env.POSTGRES_DB || 'app',
        ssl: {
          rejectUnauthorized: process.env.DB_SSL_REJECT_UNAUTHORIZED !== 'false',
          require: true // Always require SSL for PostgreSQL
        }
      };
    
    case 'mysql':
      return {
        type: 'mysql',
        connectionString: process.env.DATABASE_URL || process.env.MYSQL_URL,
        host: process.env.DB_HOST || process.env.MYSQL_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || process.env.MYSQL_PORT || '3306'),
        user: process.env.DB_USER || process.env.MYSQL_USER || 'root',
        password: process.env.DB_PASSWORD || process.env.MYSQL_PASSWORD,
        database: process.env.DB_NAME || process.env.MYSQL_DATABASE || 'app'
      };
    
    default: // sqlite
      return {
        type: 'sqlite',
        sqliteDir: process.env.SQLITE_DIR || '.',
        efsMountPath: process.env.EFS_MOUNT_PATH
      };
  }
}

// Import the specific database implementation
// This will be replaced during generation with the specific import
import * as dbImplementation from './db-{{DATABASE_TYPE}}';

/**
 * Initialize database connection
 * @returns Database client
 */
export async function db_init(): Promise<DatabaseClient> {
  const dbType = (process.env.DATABASE_TYPE || process.env.DB_TYPE || 'postgres').toLowerCase() as DatabaseType;
  
  // For the template, we use static import based on database type
  return dbImplementation.db_init();
}

/**
 * Execute a SQL query using the provided database client
 * @param client Database client from db_init()
 * @param query SQL query string
 * @param params Optional array of parameters for the query
 * @returns Array of selected rows or execution results
 */
export async function db_query(
  client: DatabaseClient,
  query: string,
  params?: any[]
): Promise<any[]> {
  return dbImplementation.db_query(client, query, params);
}

/**
 * Generates a CREATE TABLE SQL string for the specified table and fields
 * @param model The model definition
 * @returns SQL string for creating the table
 */
export function db_migrate(model: Model): string {
  const dbType = (process.env.DATABASE_TYPE || process.env.DB_TYPE || 'postgres').toLowerCase() as DatabaseType;
  return dbImplementation.db_migrate(model, dbType);
}


// Export types
export type { Model, ModelField };
