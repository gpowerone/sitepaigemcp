/*
Sitepaige v1.0.0
Database abstraction layer for multiple database support
WARNING: This file is automatically generated and should not be modified.
*/

import * as path from 'path';
import * as fs from 'fs';

interface ModelField {
  name: string;
  datatype: string;
  datatypesize: string | null;
  required: string;
  key: string | null;
  default?: any;
}

interface Model {
  id: string;
  name: string;
  fields: ModelField[];
  data_is_user_specific?: string; // Added for user-specific data
}

// Database client type that's compatible across all database types
export type DatabaseClient = any;

// Database type enum
export type DatabaseType = 'sqlite' | 'postgres' | 'mysql';

// Database configuration
export interface DatabaseConfig {
  type: DatabaseType;
  connectionString?: string; // For postgres/mysql
  host?: string;
  port?: number;
  user?: string;
  password?: string;
  database?: string;
  sqliteDir?: string; // For sqlite
  efsMountPath?: string; // For production sqlite
}

// Get database configuration from environment
export function getDatabaseConfig(): DatabaseConfig {
  const dbType = (process.env.DATABASE_TYPE || 'sqlite').toLowerCase() as DatabaseType;
  
  switch (dbType) {
    case 'postgres':
      return {
        type: 'postgres',
        connectionString: process.env.DATABASE_URL || process.env.POSTGRES_URL,
        host: process.env.DB_HOST || process.env.POSTGRES_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || process.env.POSTGRES_PORT || '5432'),
        user: process.env.DB_USER || process.env.POSTGRES_USER || 'postgres',
        password: process.env.DB_PASSWORD || process.env.POSTGRES_PASSWORD,
        database: process.env.DB_NAME || process.env.POSTGRES_DB || 'app'
      };
    
    case 'mysql':
      return {
        type: 'mysql',
        connectionString: process.env.DATABASE_URL || process.env.MYSQL_URL,
        host: process.env.DB_HOST || process.env.MYSQL_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || process.env.MYSQL_PORT || '3306'),
        user: process.env.DB_USER || process.env.MYSQL_USER || 'root',
        password: process.env.DB_PASSWORD || process.env.MYSQL_PASSWORD,
        database: process.env.DB_NAME || process.env.MYSQL_DATABASE || 'app'
      };
    
    default: // sqlite
      return {
        type: 'sqlite',
        sqliteDir: process.env.SQLITE_DIR || '.',
        efsMountPath: process.env.EFS_MOUNT_PATH
      };
  }
}

// Import the specific database implementation
// This will be replaced during generation with the specific import
import * as dbImplementation from './db-{{DATABASE_TYPE}}';

/**
 * Initialize database connection
 * @returns Database client
 */
export async function db_init(): Promise<DatabaseClient> {
  const config = getDatabaseConfig();
  return dbImplementation.db_init(config);
}

/**
 * Execute a SQL query using the provided database client
 * @param client Database client from db_init()
 * @param query SQL query string
 * @param params Optional array of parameters for the query
 * @returns Array of selected rows or execution results
 */
export async function db_query(
  client: DatabaseClient,
  query: string,
  params?: any[]
): Promise<any[]> {
  return dbImplementation.db_query(client, query, params);
}

/**
 * Generates a CREATE TABLE SQL string for the specified table and fields
 * @param model The model definition
 * @returns SQL string for creating the table
 */
export function db_migrate(model: Model): string {
  const config = getDatabaseConfig();
  return dbImplementation.db_migrate(model, config.type);
}

/**
 * Initialize the database with models and sample data
 * @param models Array of models to create tables for
 * @param sampleData Optional array of sample data SQL statements
 */
export async function initializeDatabase(
  models: Model[], 
  sampleData?: Array<{tableName: string, sql: string}>
): Promise<void> {
  const client = await db_init();
  
  try {
    console.log('Creating database tables...');
    
    // Create tables for each model
    for (const model of models) {
      const createTableSql = db_migrate(model);
      await db_query(client, createTableSql);
      console.log(`Created table: ${model.name}`);
    }
    
    // Insert sample data if provided
    if (sampleData && sampleData.length > 0) {
      console.log('Inserting sample data...');
      for (const data of sampleData) {
        try {
          await db_query(client, data.sql);
          console.log(`Inserted sample data for: ${data.tableName}`);
        } catch (error) {
          console.error(`Failed to insert sample data for ${data.tableName}:`, error);
          // Continue with other tables even if one fails
        }
      }
    }
    
    console.log('Database initialization complete');
  } catch (error) {
    console.error('Error initializing database:', error);
    throw error;
  }
}

/**
 * Close database connection(s)
 * @param dbPath Optional path for SQLite databases
 */
export async function closeDatabase(dbPath?: string): Promise<void> {
  if (dbImplementation && dbImplementation.closeDatabase) {
    return dbImplementation.closeDatabase(dbPath);
  }
}

// Export types
export type { Model, ModelField };
