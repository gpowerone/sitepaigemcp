
/*
Sitepaige API v1.0.0
WARNING: This file is automatically generated and should not be modified.
*/

import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';
import * as crypto from 'node:crypto';

import { db_init, db_query } from '../../db';
import { upsertUser, storeOAuthToken, validateSession, rotateSession } from '../../db-users';

type OAuthProvider = 'google' | 'facebook' | 'apple'  | 'github';

const OAUTH_ENDPOINTS = {
  google: 'https://oauth2.googleapis.com/token',
  facebook: 'https://graph.facebook.com/v12.0/oauth/access_token',
  apple: 'https://appleid.apple.com/auth/token',
  github: 'https://github.com/login/oauth/access_token',
};

const USER_INFO_ENDPOINTS = {
  google: 'https://www.googleapis.com/oauth2/v2/userinfo',
  facebook: 'https://graph.facebook.com/me',
  apple: 'https://appleid.apple.com/auth/userinfo',
  github: 'https://api.github.com/user',
};

export async function POST(request: Request) {
  const db = await db_init();
  
  try {
    const { code, provider, email, password } = await request.json();
    
    if (!provider) {
      return NextResponse.json(
        { error: 'No provider specified' },
        { status: 400 }
      );
    }

    // Handle username/password authentication
    if (provider === 'userpass') {
      if (!email || !password) {
        return NextResponse.json(
          { error: 'Email and password are required' },
          { status: 400 }
        );
      }

      const { authenticateUser, createPasswordAuthTable } = await import('../../db-password-auth');
      const { upsertUser } = await import('../../db-users');
      
      // Ensure password auth table exists
      await createPasswordAuthTable();

      try {
        // Authenticate the user
        const authRecord = await authenticateUser(email, password);
        
        if (!authRecord) {
          return NextResponse.json(
            { error: 'Invalid email or password' },
            { status: 401 }
          );
        }

        // Create or update user in the main Users table
        const user = await upsertUser(
          `password_${authRecord.id}`, // Unique OAuth ID for password users
          'userpass' as any, // Source type
          email.split('@')[0], // Username from email
          email,
          undefined // No avatar for password auth
        );

        // Delete existing sessions for this user
        const existingSessions = await db_query(db, 
          "SELECT id FROM usersession WHERE userid = ?", 
          [user.userid]
        );
        
        if (existingSessions && existingSessions.length > 0) {
          const sessionIds = existingSessions.map(session => session.id);
          const placeholders = sessionIds.map(() => '?').join(',');
          await db_query(db, `DELETE FROM usersession WHERE id IN (${placeholders})`, sessionIds);
        }

        // Generate secure session token and ID
        const sessionId = crypto.randomUUID();
        const sessionToken = crypto.randomBytes(32).toString('base64url');

        // Create new session with secure token
        await db_query(db, 
          "INSERT INTO usersession (id, sessiontoken, userid, expirationdate) VALUES (?, ?, ?, ?)",
          [sessionId, sessionToken, user.userid, new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()]
        );

        // Set session cookie with secure token
        const sessionCookie = await cookies();
        sessionCookie.set({
          name: 'session_id', 
          value: sessionToken,
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
          maxAge: 30 * 24 * 60 * 60, // 30 days
          path: '/',
        });

        // Create a completely clean object to avoid any database result object issues
        const cleanUserData = {
          userid: String(user.userid),
          userName: String(user.username),
          avatarURL: String(user.avatarurl || ''),
          userLevel: Number(user.userlevel),
          isAdmin: Number(user.userlevel) === 2
        };
        
        return NextResponse.json({ 
          success: true,
          user: cleanUserData
        });

      } catch (error: any) {
        if (error.message === 'Email not verified') {
          return NextResponse.json(
            { error: 'Please verify your email before logging in' },
            { status: 403 }
          );
        }
        throw error;
      }
    }

    // Handle OAuth authentication
    if (!code) {
      return NextResponse.json(
        { error: 'No authorization code specified' },
        { status: 400 }
      );
    }

    // Check if provider is valid OAuth provider (excluding email)
    const validProvider = provider as Exclude<OAuthProvider, 'email'>;
    if (!OAUTH_ENDPOINTS[validProvider]) {
      return NextResponse.json(
        { error: 'Invalid OAuth provider' },
        { status: 400 }
      );
    }

    let userData = {
        id: '',
        name: '',
        email: '',
        avatar_url: '',
    };
    let tokenData;
   
    // Handle OAuth exchange manually
    const tokenResponse = await fetch(OAUTH_ENDPOINTS[validProvider], {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'application/json',
        },
        body: new URLSearchParams({
            client_id: process.env[`NEXT_PUBLIC_${provider.toUpperCase()}_CLIENT_ID`]!,
            client_secret: process.env[`${provider.toUpperCase()}_CLIENT_SECRET`]!,
            code,
            redirect_uri: `${process.env.NODE_ENV === 'production' ? process.env.DOMAIN : process.env.LOCAL_DOMAIN}/logincallback`,
            grant_type: 'authorization_code'
        }).toString(),
    });

    if (!tokenResponse.ok) {
        return NextResponse.json(
            { error: 'Failed to exchange code for token' },
            { status: 400 }
        );
    }
  
    tokenData = await tokenResponse.json();

    // Get user data from provider
    const userResponse = await fetch(USER_INFO_ENDPOINTS[validProvider], {
        headers: {
            Authorization: `Bearer ${tokenData.access_token}`,
        },
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: 'Failed to fetch user data' },
        { status: 400 }
      );
    }

    let fetchedUserData = await userResponse.json();

    switch (validProvider) {
   
        case 'google':
            userData.id = fetchedUserData.id;
            userData.name = fetchedUserData.name;
            userData.email = fetchedUserData.email;
            userData.avatar_url = fetchedUserData.picture;
            break;

        case 'facebook':
            userData.id = fetchedUserData.id;
            userData.name = fetchedUserData.name;
            userData.email = fetchedUserData.email;
            userData.avatar_url = fetchedUserData.picture?.data?.url;
            break;

        case 'apple':
            userData.id = fetchedUserData.sub;
            userData.name = `${fetchedUserData.given_name || ''} ${fetchedUserData.family_name || ''}`.trim();
            userData.email = fetchedUserData.email;
            // Apple doesn't provide avatar URL
            break;

        case 'github':
            userData.id = fetchedUserData.id?.toString();
            userData.name = fetchedUserData.name || fetchedUserData.login;
            userData.email = fetchedUserData.email;
            userData.avatar_url = fetchedUserData.avatar_url;
            break;

        default:
            return NextResponse.json(
            { error: 'Invalid provider' },
            { status: 400 }
            );
    }
    
    // Create or update user using the new user management system
    const user = await upsertUser(
      userData.id,
      validProvider,
      userData.name,
      userData.email,
      userData.avatar_url
    );
    
    // Store OAuth tokens securely
    await storeOAuthToken(
      user.userid,
      validProvider,
      tokenData.access_token,
      tokenData.refresh_token,
      tokenData.expires_in
    );
    
    // Delete existing sessions for this user
    const existingSessions = await db_query(db, 
      "SELECT id FROM usersession WHERE userid = ?", 
      [user.userid]
    );
    
    if (existingSessions && existingSessions.length > 0) {
        const sessionIds = existingSessions.map(session => session.id);
        const placeholders = sessionIds.map(() => '?').join(',');
        await db_query(db, `DELETE FROM usersession WHERE id IN (${placeholders})`, sessionIds);
    }

    // Generate secure session token and ID
    const sessionId = crypto.randomUUID();
    const sessionToken = crypto.randomBytes(32).toString('base64url');

    // Create new session with secure token
    await db_query(db, 
      "INSERT INTO usersession (id, sessiontoken, userid, expirationdate) VALUES (?, ?, ?, ?)",
      [sessionId, sessionToken, user.userid, new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()]
    );

    // Set session cookie with secure token
    const sessionCookie = await cookies();
    sessionCookie.set({
      name: 'session_id', 
      value: sessionToken,
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
      maxAge: 30 * 24 * 60 * 60, // 30 days
      path: '/',
    });

    // Create a completely clean object to avoid any database result object issues
    const cleanUserData = {
      userid: String(user.userid),
      userName: String(user.username),
      avatarURL: String(user.avatarurl || ''),
      userLevel: Number(user.userlevel),
      isAdmin: Number(user.userlevel) === 2
    };
    
    return NextResponse.json({ 
      success: true,
      user: cleanUserData
    });

  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Authentication failed' },
      { status: 500 }
    );
  }
}

export async function GET() {
  try {
    // Get session token from cookies
    const sessionCookie = await cookies();
    const sessionToken = sessionCookie.get('session_id')?.value;

    if (!sessionToken) {
      return NextResponse.json(
        { user: null },
        { status: 200 }
      );
    }

    // Validate session and get user details
    const sessionData = await validateSession(sessionToken);

    if (!sessionData.valid || !sessionData.user) {
      // Clear the invalid cookie
      const response = NextResponse.json(
        { user: null },
        { status: 401 }
      );
      response.cookies.delete('session_id');
      return response;
    }

    // Check if session needs rotation
    if (sessionData.needsRotation) {
      const newSessionToken = await rotateSession(sessionToken);
      
      if (newSessionToken) {
        // Create response with new session token
        const response = NextResponse.json({
          user: {
            userid: sessionData.user.userid,
            username: sessionData.user.username,
            avatarurl: sessionData.user.avatarurl,
            email: sessionData.user.email,
            userlevel: sessionData.user.userlevel,
            isadmin: sessionData.user.userlevel === 2,
            source: sessionData.user.source,
            lastlogindate: sessionData.user.lastlogindate
          }
        });
        
        // Set new session cookie
        response.cookies.set({
          name: 'session_id',
          value: newSessionToken,
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
          maxAge: 30 * 24 * 60 * 60, // 30 days
          path: '/',
        });
        
        return response;
      }
    }

    // Return user data in a consistent format
    return NextResponse.json({
      user: {
        userid: sessionData.user.userid,
        username: sessionData.user.username,
        avatarurl: sessionData.user.avatarurl,
        email: sessionData.user.email,
        userlevel: sessionData.user.userlevel,
        isadmin: sessionData.user.userlevel === 2,
        source: sessionData.user.source,
        lastlogindate: sessionData.user.lastlogindate
      }
    });

  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to get user profile' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  const db = await db_init();
  
  try {
    // Get session token from cookies
    const sessionCookie = await cookies();
    const sessionToken = sessionCookie.get('session_id')?.value;

    if (!sessionToken) {
      return NextResponse.json(
        { error: 'No session found' },
        { status: 401 }
      );
    }

    // Delete session from database using the actual session token
    await db_query(db, 
      "DELETE FROM usersession WHERE sessiontoken = ?", 
      [sessionToken]
    );

    // Create response with cookie deletion
    const response = NextResponse.json({ success: true });
    response.cookies.delete('session_id');

    return response;

  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to logout' },
      { status: 500 }
    );
  }
}
