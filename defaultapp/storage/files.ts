/*
Sitepaige v1.0.0
WARNING: This file is automatically generated and should not be modified.
*/

import fs from 'fs/promises';
import path from 'path';
import { randomBytes } from 'crypto';

// File storage for the application
const fileStorage: { [key: string]: string } = {};
const fileNames: { [key: string]: string } = {};

/**
 * Get the files storage path
 * Uses EFS_MOUNT_PATH for production (in container with EFS) or SQLITE_DIR for local development
 */
function getFilesStoragePath(): string {
  const efsMountPath = process.env.EFS_MOUNT_PATH;
  const sqliteDir = process.env.SQLITE_DIR || '.';
  
  if (efsMountPath) {
    // In production with EFS
    return path.join(efsMountPath, 'files');
  } else {
    // In local development - use a separate files directory
    return path.join(sqliteDir, 'files');
  }
}

/**
 * Store file function that writes files to the filesystem and returns a reference
 * @param filename The original filename
 * @param filedata Base64 encoded file data
 * @param isImage Whether this is an image file
 * @returns Promise that resolves to a file reference string (path starting with /files/)
 */
export async function store_file(filename: string, filedata: string, isImage: boolean): Promise<string> {
  console.log(`üìÅ Storing ${isImage ? 'image' : 'file'}: ${filename} (${filedata.length} bytes)`);
  
  try {
    // Generate a unique key for this file
    const fileKey = `${Date.now()}_${randomBytes(6).toString('hex')}`;
    
    // Determine file extension
    const extension = path.extname(filename) || (isImage ? '.png' : '.bin');
    const safeFilename = `${fileKey}${extension}`;
    
    // Get storage directory and create subdirectories if needed
    const storageBasePath = getFilesStoragePath();
    const storageDir = path.join(storageBasePath, isImage ? 'images' : 'documents');
    await fs.mkdir(storageDir, { recursive: true });
    
    // Write file to filesystem
    const filePath = path.join(storageDir, safeFilename);
    const buffer = Buffer.from(filedata, 'base64');
    await fs.writeFile(filePath, buffer);
    
    // Store metadata
    fileStorage[fileKey] = filePath;
    fileNames[fileKey] = filename;
    
    console.log(`‚úÖ File stored successfully: ${filePath}`);
    
    // Return the public path that will be used to access the file
    // This path starts with /files/ and matches what the API route will serve
    const publicPath = `/files/${isImage ? 'images' : 'documents'}/${safeFilename}`;
    return publicPath;
  } catch (error) {
    console.error('‚ùå Error storing file:', error);
    throw new Error(`Failed to store file: ${error}`);
  }
}

/**
 * Get the filesystem path for a stored file
 * @param fileKey The file key returned from store_file
 * @returns The filesystem path or undefined if not found
 */
export function getStoredFilePath(fileKey: string): string | undefined {
  return fileStorage[fileKey];
}

/**
 * Get the original filename for a stored file
 * @param fileKey The file key returned from store_file
 * @returns The original filename or undefined if not found
 */
export function getStoredFileName(fileKey: string): string | undefined {
  return fileNames[fileKey];
}

/**
 * Get the file data as base64 for a stored file
 * @param fileKey The file key returned from store_file
 * @returns Promise that resolves to base64 file data or undefined if not found
 */
export async function getStoredFileData(fileKey: string): Promise<string | undefined> {
  const filePath = fileStorage[fileKey];
  if (!filePath) {
    return undefined;
  }
  
  try {
    const buffer = await fs.readFile(filePath);
    return buffer.toString('base64');
  } catch (error) {
    console.error('Error reading stored file:', error);
    return undefined;
  }
}

/**
 * Delete a stored file from the filesystem
 * @param fileKey The file key returned from store_file
 * @returns Promise that resolves to true if deleted, false if not found
 */
export async function deleteStoredFile(fileKey: string): Promise<boolean> {
  const filePath = fileStorage[fileKey];
  if (!filePath) {
    return false;
  }
  
  try {
    await fs.unlink(filePath);
    delete fileStorage[fileKey];
    delete fileNames[fileKey];
    console.log(`üóëÔ∏è File deleted: ${filePath}`);
    return true;
  } catch (error) {
    console.error('Error deleting stored file:', error);
    return false;
  }
}

/**
 * List all stored files
 * @returns Array of objects containing file information
 */
export function listStoredFiles(): Array<{fileKey: string, filename: string, path: string}> {
  return Object.keys(fileStorage).map(fileKey => ({
    fileKey,
    filename: fileNames[fileKey],
    path: fileStorage[fileKey]
  }));
}

/**
 * Initialize global store_file function for generated API code
 * This makes store_file available in the same way as the preview environment
 */
export function initializeGlobalStorageAPI(): void {
  // Make store_file available globally for API code execution
  (global as any).store_file = store_file;
  (global as any).getStoredFilePath = getStoredFilePath;
  (global as any).getStoredFileName = getStoredFileName;
  (global as any).getStoredFileData = getStoredFileData;
  
  console.log('‚úÖ Global storage API initialized');
}
