/*
Sitepaige v1.0.0
PostgreSQL database implementation
WARNING: This file is automatically generated and should not be modified.
*/

import { Client, Pool } from 'pg';
import { sanitizeTableName } from './util';
import type { DatabaseConfig, Model, ModelField } from './db';

// Connection pool for better performance
let pool: Pool | null = null;

/**
 * Initialize database connection
 * @returns Database client (Pool)
 */
export async function db_init(config: DatabaseConfig): Promise<Pool> {
  // Return existing pool if already initialized
  if (pool) {
    return pool;
  }

  try {
    // Create connection configuration
    const poolConfig: any = {};
    
    if (config.connectionString) {
      poolConfig.connectionString = config.connectionString;
    } else {
      poolConfig.host = config.host;
      poolConfig.port = config.port;
      poolConfig.user = config.user;
      poolConfig.password = config.password;
      poolConfig.database = config.database;
    }
    
    // Additional pool configuration
    poolConfig.max = 20; // Maximum number of clients in the pool
    poolConfig.idleTimeoutMillis = 30000;
    poolConfig.connectionTimeoutMillis = 2000;
    
    // Create the pool
    pool = new Pool(poolConfig);
    
    // Test the connection
    await pool.query('SELECT NOW()');
    
    return pool;
  } catch (error) {
    throw error;
  }
}

/**
 * Execute a SQL query using the provided PostgreSQL client
 * @param client Database client from db_init()
 * @param query SQL query string (PostgreSQL syntax with $1, $2... parameter placeholders)
 * @param params Optional array of parameters for the query
 * @returns Array of selected rows or execution results
 */
export async function db_query(
  client: Pool,
  query: string,
  params?: any[]
): Promise<any[]> {
  try {
    // Convert SQLite ? placeholders to PostgreSQL $1, $2, etc.
    let pgQuery = query;
    let paramIndex = 1;
    while (pgQuery.includes('?')) {
      pgQuery = pgQuery.replace('?', `$${paramIndex}`);
      paramIndex++;
    }
    
    // Execute the query
    const result = await client.query(pgQuery, params);
    
    // Return rows for SELECT queries, or affected rows info for others
    if (result.command === 'SELECT') {
      return result.rows;
    } else {
      return [{
        changes: result.rowCount,
        command: result.command
      }];
    }
    
  } catch (error) {
    // If table doesn't exist for SELECT, return empty array
    if (error instanceof Error && error.message.includes('does not exist') && query.trim().toUpperCase().startsWith('SELECT')) {
      return [];
    }
    throw error;
  }
}

/**
 * Generates a CREATE TABLE SQL string for the specified table and fields
 * @param model The model definition
 * @param dbType Database type
 * @returns SQL string for creating the table
 */
export function db_migrate(model: Model, dbType: string): string {
  const sanitizedTableName = sanitizeTableName(model.name);
  
  // Start with the model's fields
  let fields = [...model.fields];
  
  // Add userid field if data is user specific
  if (model.data_is_user_specific === "true") {
    fields.push({
      name: 'userid',
      datatype: 'UUID',
      datatypesize: null,
      key: 'foreign',
      required: 'true',
      default: undefined
    });
  }
  
  // Map SQL data types for PostgreSQL
  const sqlTypeMap: { [key: string]: string } = {
    'UUID': 'UUID',
    'TINYINT': 'SMALLINT',
    'SMALLINT': 'SMALLINT',
    'BIGINT': 'BIGINT',
    'INT128': 'NUMERIC(39,0)',
    'VARCHAR': 'VARCHAR',
    'TEXT': 'TEXT',
    'BINARY': 'BYTEA',
    'DATE': 'DATE',
    'TIME': 'TIME',
    'DATETIME': 'TIMESTAMP',
    'DOUBLE': 'DOUBLE PRECISION',
    'FLOAT': 'REAL',
    'BOOLEAN': 'BOOLEAN'
  };

  // Build column definitions
  const columnDefs = fields.sort((a, b) => (b.key === 'primary' ? 1 : 0) - (a.key === 'primary' ? 1 : 0)).map(field => {
    const dataType = field.datatype.toUpperCase();
    let sqlType = sqlTypeMap[dataType] || dataType;
    
    // Add size for VARCHAR
    if (dataType === 'VARCHAR' && field.datatypesize) {
      sqlType = `VARCHAR(${field.datatypesize})`;
    }
    
    let def = `"${field.name}" ${sqlType}`;
    
    // Add NOT NULL if required
    if (field.required === "true") {
        def += ' NOT NULL';
    }

    // Add default if specified
    if (field.default !== undefined) {
      if (field.datatype === 'VARCHAR' || field.datatype === 'TEXT') {
        def += ` DEFAULT '${field.default}'`;
      } else if (field.datatype === 'BOOLEAN') {
        def += ` DEFAULT ${field.default === 'true' || field.default === true}`;
      } else {
        def += ` DEFAULT ${field.default}`;
      }
    }

    // Add primary key constraint
    if (field.key === 'primary') {
      def += ' PRIMARY KEY';
    }
    
    return def;
  }).join(',\n  ');

  // Add foreign key constraints at the end
  const foreignKeys: string[] = [];
  if (model.data_is_user_specific === "true") {
    foreignKeys.push(`FOREIGN KEY ("userid") REFERENCES "Users" ("userid")`);
  }
  
  const allConstraints = foreignKeys.length > 0 
    ? columnDefs + ',\n  ' + foreignKeys.join(',\n  ')
    : columnDefs;

  // Build the CREATE TABLE statement
  const sql = `CREATE TABLE IF NOT EXISTS "${sanitizedTableName}" (\n  ${allConstraints}\n);`;

  return sql;
}

/**
 * Close database connection(s)
 */
export async function closeDatabase(): Promise<void> {
  if (pool) {
    await pool.end();
    pool = null;
  }
}
