
/*
Sitepaige API v1.0.0
WARNING: This file is automatically generated and should not be modified.
*/

import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

import { db_init, db_query } from '../../db';
import { upsertUser, ensureAuthTables, storeOAuthToken, validateSession, rotateSession } from '../../db-users';
import { validateCsrfToken } from '../../csrf';

type OAuthProvider = 'google' | 'facebook' | 'apple'  | 'github';

const OAUTH_ENDPOINTS = {
  google: 'https://oauth2.googleapis.com/token',
  facebook: 'https://graph.facebook.com/v12.0/oauth/access_token',
  apple: 'https://appleid.apple.com/auth/token',
  github: 'https://github.com/login/oauth/access_token',
};

const USER_INFO_ENDPOINTS = {
  google: 'https://www.googleapis.com/oauth2/v2/userinfo',
  facebook: 'https://graph.facebook.com/me',
  apple: 'https://appleid.apple.com/auth/userinfo',
  github: 'https://api.github.com/user',
};

export async function POST(request: Request) {
  // Ensure authentication tables exist
  await ensureAuthTables();
  
  const db = await db_init();
  
  try {
    const { code, provider } = await request.json();
    
    if (!code || !provider) {
      return NextResponse.json(
        { error: 'No authorization code or provider specified' },
        { status: 400 }
      );
    }

    // Check if provider is valid OAuth provider (excluding email)
    const validProvider = provider as Exclude<OAuthProvider, 'email'>;
    if (!OAUTH_ENDPOINTS[validProvider]) {
      return NextResponse.json(
        { error: 'Invalid OAuth provider' },
        { status: 400 }
      );
    }

    let userData = {
        ID: '',
        name: '',
        email: '',
        avatar_url: '',
    };
    let tokenData;
   
    // Handle OAuth exchange manually
    const tokenResponse = await fetch(OAUTH_ENDPOINTS[validProvider], {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'application/json',
        },
        body: new URLSearchParams({
            client_id: process.env[`NEXT_PUBLIC_${provider.toUpperCase()}_CLIENT_ID`]!,
            client_secret: process.env[`${provider.toUpperCase()}_CLIENT_SECRET`]!,
            code,
            redirect_uri: `${process.env.NODE_ENV === 'production' ? process.env.DOMAIN : process.env.LOCAL_DOMAIN}/logincallback`,
            grant_type: 'authorization_code'
        }).toString(),
    });

    if (!tokenResponse.ok) {
        return NextResponse.json(
            { error: 'Failed to exchange code for token' },
            { status: 400 }
        );
    }
  
    tokenData = await tokenResponse.json();

    // Get user data from provider
    const userResponse = await fetch(USER_INFO_ENDPOINTS[validProvider], {
        headers: {
            Authorization: `Bearer ${tokenData.access_token}`,
        },
    });

    if (!userResponse.ok) {
      return NextResponse.json(
        { error: 'Failed to fetch user data' },
        { status: 400 }
      );
    }

    let fetchedUserData = await userResponse.json();

    switch (validProvider) {
   
        case 'google':
            userData.ID = fetchedUserData.id;
            userData.name = fetchedUserData.name;
            userData.email = fetchedUserData.email;
            userData.avatar_url = fetchedUserData.picture;
            break;

        case 'facebook':
            userData.ID = fetchedUserData.id;
            userData.name = fetchedUserData.name;
            userData.email = fetchedUserData.email;
            userData.avatar_url = fetchedUserData.picture?.data?.url;
            break;

        case 'apple':
            userData.ID = fetchedUserData.sub;
            userData.name = `${fetchedUserData.given_name || ''} ${fetchedUserData.family_name || ''}`.trim();
            userData.email = fetchedUserData.email;
            // Apple doesn't provide avatar URL
            break;

        case 'github':
            userData.ID = fetchedUserData.id?.toString();
            userData.name = fetchedUserData.name || fetchedUserData.login;
            userData.email = fetchedUserData.email;
            userData.avatar_url = fetchedUserData.avatar_url;
            break;

        default:
            return NextResponse.json(
            { error: 'Invalid provider' },
            { status: 400 }
            );
    }
    
    // Create or update user using the new user management system
    const user = await upsertUser(
      userData.ID,
      validProvider,
      userData.name,
      userData.email,
      userData.avatar_url
    );
    
    // Store OAuth tokens securely
    await storeOAuthToken(
      user.userid,
      validProvider,
      tokenData.access_token,
      tokenData.refresh_token,
      tokenData.expires_in
    );
    
    // Delete existing sessions for this user
    const existingSessions = await db_query(db, 
      "SELECT ID FROM UserSession WHERE userid = ?", 
      [user.userid]
    );
    
    if (existingSessions && existingSessions.length > 0) {
        const sessionIds = existingSessions.map(session => session.ID);
        const placeholders = sessionIds.map(() => '?').join(',');
        await db_query(db, `DELETE FROM UserSession WHERE ID IN (${placeholders})`, sessionIds);
    }

    // Generate secure session token and ID
    const sessionId = crypto.randomUUID();
    const sessionToken = crypto.randomBytes(32).toString('base64url');

    // Create new session with secure token
    await db_query(db, 
      "INSERT INTO UserSession (ID, SessionToken, userid, ExpirationDate) VALUES (?, ?, ?, ?)",
      [sessionId, sessionToken, user.userid, new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()]
    );

    // Set session cookie with secure token
    const sessionCookie = await cookies();
    sessionCookie.set({
      name: 'session_id', 
      value: sessionToken,
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
      maxAge: 30 * 24 * 60 * 60, // 30 days
      path: '/',
    });

    // Create a completely clean object to avoid any database result object issues
    const cleanUserData = {
      userid: String(user.userid),
      userName: String(user.UserName),
      avatarURL: String(user.AvatarURL || ''),
      userLevel: Number(user.UserLevel),
      isAdmin: Number(user.UserLevel) === 2
    };
    
    return NextResponse.json({ 
      success: true,
      user: cleanUserData
    });

  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Authentication failed' },
      { status: 500 }
    );
  }
}

export async function GET() {
  // Ensure authentication tables exist
  await ensureAuthTables();
  
  try {
    // Get session token from cookies
    const sessionCookie = await cookies();
    const sessionToken = sessionCookie.get('session_id')?.value;

    if (!sessionToken) {
      return NextResponse.json(
        { user: null },
        { status: 200 }
      );
    }

    // Validate session and get user details
    const sessionData = await validateSession(sessionToken);

    if (!sessionData.valid || !sessionData.user) {
      // Clear the invalid cookie
      const response = NextResponse.json(
        { user: null },
        { status: 401 }
      );
      response.cookies.delete('session_id');
      return response;
    }

    // Check if session needs rotation
    if (sessionData.needsRotation) {
      const newSessionToken = await rotateSession(sessionToken);
      
      if (newSessionToken) {
        // Create response with new session token
        const response = NextResponse.json({
          user: {
            userid: sessionData.user.userid,
            UserName: sessionData.user.UserName,
            AvatarURL: sessionData.user.AvatarURL,
            Email: sessionData.user.Email,
            UserLevel: sessionData.user.UserLevel,
            IsAdmin: sessionData.user.UserLevel === 2,
            Source: sessionData.user.Source,
            LastLoginDate: sessionData.user.LastLoginDate
          }
        });
        
        // Set new session cookie
        response.cookies.set({
          name: 'session_id',
          value: newSessionToken,
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
          maxAge: 30 * 24 * 60 * 60, // 30 days
          path: '/',
        });
        
        return response;
      }
    }

    // Return user data in a consistent format
    return NextResponse.json({
      user: {
        userid: sessionData.user.userid,
        UserName: sessionData.user.UserName,
        AvatarURL: sessionData.user.AvatarURL,
        Email: sessionData.user.Email,
        UserLevel: sessionData.user.UserLevel,
        IsAdmin: sessionData.user.UserLevel === 2,
        Source: sessionData.user.Source,
        LastLoginDate: sessionData.user.LastLoginDate
      }
    });

  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to get user profile' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request) {
  // Validate CSRF token for logout
  const isValidCsrf = await validateCsrfToken(request);
  if (!isValidCsrf) {
    return NextResponse.json(
      { error: 'Invalid CSRF token' },
      { status: 403 }
    );
  }
  
  // Ensure authentication tables exist
  await ensureAuthTables();
  
  const db = await db_init();
  
  try {
    // Get session token from cookies
    const sessionCookie = await cookies();
    const sessionToken = sessionCookie.get('session_id')?.value;

    if (!sessionToken) {
      return NextResponse.json(
        { error: 'No session found' },
        { status: 401 }
      );
    }

    // Delete session from database using the actual session token
    await db_query(db, 
      "DELETE FROM UserSession WHERE SessionToken = ?", 
      [sessionToken]
    );

    // Create response with cookie deletion
    const response = NextResponse.json({ success: true });
    response.cookies.delete('session_id');

    return response;

  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to logout' },
      { status: 500 }
    );
  }
}
