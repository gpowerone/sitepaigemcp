/*
Sitepaige v1.0.0
MySQL database implementation
WARNING: This file is automatically generated and should not be modified.
*/

import mysql from 'mysql2/promise';
import type { DatabaseConfig, Model, ModelField } from './db';

// Connection pool for better performance
let pool: mysql.Pool | null = null;

/**
 * Initialize database connection
 * @returns Database client (Pool)
 */
export async function db_init(config: DatabaseConfig): Promise<mysql.Pool> {
  // Skip database initialization during build time
  if (typeof window === 'undefined' && !process.env.HOSTNAME && process.env.NODE_ENV === 'production') {
    // Return a mock pool object that won't cause errors
    return {} as mysql.Pool;
  }
  
  // Return existing pool if already initialized
  if (pool) {
    return pool;
  }

  try {
    // Create connection configuration
    const poolConfig: mysql.PoolOptions = {
      host: config.host,
      port: config.port,
      user: config.user,
      password: config.password,
      database: config.database,
      waitForConnections: true,
      connectionLimit: 20,
      queueLimit: 0,
      enableKeepAlive: true,
      keepAliveInitialDelay: 0
    };
    
    // Use connection string if provided
    if (config.connectionString) {
      const url = new URL(config.connectionString);
      poolConfig.host = url.hostname;
      poolConfig.port = parseInt(url.port || '3306');
      poolConfig.user = url.username;
      poolConfig.password = url.password;
      poolConfig.database = url.pathname.substring(1);
    }
    
    // Create the pool
    pool = mysql.createPool(poolConfig);
    
    // Test the connection
    const connection = await pool.getConnection();
    await connection.ping();
    connection.release();
    
    return pool;
  } catch (error) {
    throw error;
  }
}

/**
 * Execute a SQL query using the provided MySQL client
 * @param client Database client from db_init()
 * @param query SQL query string (MySQL syntax with ? parameter placeholders)
 * @param params Optional array of parameters for the query
 * @returns Array of selected rows or execution results
 */
export async function db_query(
  client: mysql.Pool,
  query: string,
  params?: any[]
): Promise<any[]> {
  // Return empty results during build time
  if (typeof window === 'undefined' && !process.env.HOSTNAME && process.env.NODE_ENV === 'production') {
    return [];
  }
  
  try {
    // MySQL uses ? placeholders like SQLite, so no conversion needed
    const [results] = await client.execute(query, params);
    
    // Handle different result types
    if (Array.isArray(results)) {
      // SELECT query results
      return results;
    } else {
      // INSERT, UPDATE, DELETE results
      const resultInfo = results as mysql.ResultSetHeader;
      return [{
        changes: resultInfo.affectedRows,
        insertId: resultInfo.insertId
      }];
    }
    
  } catch (error) {
    // If table doesn't exist for SELECT, return empty array
    if (error instanceof Error && error.message.includes("doesn't exist") && query.trim().toUpperCase().startsWith('SELECT')) {
      return [];
    }
    throw error;
  }
}

/**
 * Generates a CREATE TABLE SQL string for the specified table and fields
 * @param model The model definition
 * @param dbType Database type
 * @returns SQL string for creating the table
 */
export function db_migrate(model: Model, dbType: string): string {
  const sanitizedTableName = model.name;
  
  // Start with the model's fields
  let fields = [...model.fields];
  
  // Add userid field if data is user specific
  if (model.data_is_user_specific === "true") {
    fields.push({
      name: 'userid',
      datatype: 'VARCHAR',
      datatypesize: '36', // UUID as string
      key: 'foreign',
      required: 'true',
      default: undefined
    });
  }
  
  // Map SQL data types for MySQL
  const sqlTypeMap: { [key: string]: string } = {
    'UUID': 'VARCHAR(36)',
    'TINYINT': 'TINYINT',
    'SMALLINT': 'SMALLINT',
    'BIGINT': 'BIGINT',
    'INT128': 'DECIMAL(39,0)',
    'VARCHAR': 'VARCHAR',
    'TEXT': 'TEXT',
    'BINARY': 'BLOB',
    'DATE': 'DATE',
    'TIME': 'TIME',
    'DATETIME': 'DATETIME',
    'DOUBLE': 'DOUBLE',
    'FLOAT': 'FLOAT',
    'BOOLEAN': 'BOOLEAN'
  };

  // Build column definitions
  const columnDefs = fields.sort((a, b) => (b.key === 'primary' ? 1 : 0) - (a.key === 'primary' ? 1 : 0)).map(field => {
    const dataType = field.datatype.toUpperCase();
    let sqlType = sqlTypeMap[dataType] || dataType;
    
    // Add size for VARCHAR
    if (dataType === 'VARCHAR' && field.datatypesize) {
      sqlType = `VARCHAR(${field.datatypesize})`;
    }
    
    let def = `\`${field.name}\` ${sqlType}`;
    
    // Add NOT NULL if required
    if (field.required === "true") {
        def += ' NOT NULL';
    }

    // Add default if specified
    if (field.default !== undefined) {
      if (field.datatype === 'VARCHAR' || field.datatype === 'TEXT') {
        def += ` DEFAULT '${field.default}'`;
      } else if (field.datatype === 'BOOLEAN') {
        def += ` DEFAULT ${field.default === 'true' || field.default === true ? 1 : 0}`;
      } else {
        def += ` DEFAULT ${field.default}`;
      }
    }

    // Add primary key constraint
    if (field.key === 'primary') {
      def += ' PRIMARY KEY';
    }
    
    return def;
  }).join(',\n  ');

  // Add foreign key constraints at the end
  const foreignKeys: string[] = [];
  if (model.data_is_user_specific === "true") {
    foreignKeys.push(`FOREIGN KEY (\`userid\`) REFERENCES \`Users\` (\`userid\`)`);
  }
  
  const allConstraints = foreignKeys.length > 0 
    ? columnDefs + ',\n  ' + foreignKeys.join(',\n  ')
    : columnDefs;

  // Build the CREATE TABLE statement
  const sql = `CREATE TABLE IF NOT EXISTS \`${sanitizedTableName}\` (\n  ${allConstraints}\n);`;

  return sql;
}

/**
 * Close database connection(s)
 */
export async function closeDatabase(): Promise<void> {
  if (pool) {
    await pool.end();
    pool = null;
  }
}
