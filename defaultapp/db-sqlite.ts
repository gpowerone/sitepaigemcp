/*
Sitepaige v1.0.0
SQLite database implementation
WARNING: This file is automatically generated and should not be modified.
*/

import Database from 'better-sqlite3';
import { sanitizeTableName } from './util';
import * as path from 'path';
import * as fs from 'fs';
import type { DatabaseConfig, Model, ModelField } from './db';

// Map to store multiple database connections by path
const dbConnections: Map<string, Database.Database> = new Map();

/**
 * Get the default database path
 */
function getDefaultDbPath(config: DatabaseConfig): string {
  // Use EFS_MOUNT_PATH for production (in container with EFS)
  // Use SQLITE_DIR for local development
  const efsMountPath = config.efsMountPath;
  const sqliteDir = config.sqliteDir || '.';
  
  if (efsMountPath) {
    // In production with EFS
    return path.join(efsMountPath, 'data', 'app.db');
  } else {
    // In local development
    return path.join(sqliteDir, 'app.db');
  }
}

/**
 * Initialize database connection
 * Uses default database path based on EFS_MOUNT_PATH (production) or SQLITE_DIR (development).
 * If the file doesn't exist, it will be created automatically.
 * @returns Database client
 */
export async function db_init(config: DatabaseConfig): Promise<Database.Database> {
  // Always use the default path - no parameter needed
  const actualPath = getDefaultDbPath(config);
  
  // Check if we already have a connection to this database
  const existingConnection = dbConnections.get(actualPath);
  if (existingConnection) {
    return existingConnection;
  }

  try {
    // Ensure the directory exists
    const dir = path.dirname(actualPath);
    if (dir && dir !== '.' && dir !== '/') {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Create database connection (SQLite will create the file if it doesn't exist)
    const newDb = new Database(actualPath);
    
    // Enable foreign keys for proper constraint enforcement
    newDb.pragma('foreign_keys = ON');
    
    // Store the connection
    dbConnections.set(actualPath, newDb);
    
    return newDb;
  } catch (error) {
    throw error;
  }
}

/**
 * Execute a SQL query using the provided SQLite database client
 * @param client Database client from db_init()
 * @param query SQL query string (SQLite syntax with ? parameter placeholders)
 * @param params Optional array of parameters for the query
 * @returns Array of selected rows or execution results
 */
export async function db_query(
  client: Database.Database,
  query: string,
  params?: any[]
): Promise<any[]> {
  try {
    // Convert booleans to integers for SQLite3 compatibility
    const queryParams = (params || []).map(param => 
      typeof param === 'boolean' ? (param ? 1 : 0) : param
    );
    
    // Check if the query contains multiple statements (separated by semicolons)
    const statements = query.split(';').map(s => s.trim()).filter(s => s.length > 0);
    
    if (statements.length > 1) {
      // Handle multiple statements
      const results: any[] = [];
      
      for (const statement of statements) {
        const queryType = statement.trim().toUpperCase().split(' ')[0];
        
        if (queryType === 'SELECT') {
          // For SELECT queries, return results array
          const stmt = client.prepare(statement);
          const stmtResults = stmt.all(...queryParams);
          results.push(...stmtResults);
        } else {
          // For INSERT, UPDATE, DELETE queries, execute and return info
          const stmt = client.prepare(statement);
          const result = stmt.run(...queryParams);
          
          // Add standardized result info
          results.push({
            changes: result.changes,
            lastInsertRowid: result.lastInsertRowid
          });
        }
      }
      
      return results;
    } else {
      // Handle single statement (original logic)
      const singleQuery = statements[0] || query.trim();
      const queryType = singleQuery.trim().toUpperCase().split(' ')[0];
      
      if (queryType === 'SELECT') {
        // For SELECT queries, return results array
        const stmt = client.prepare(singleQuery);
        const results = stmt.all(...queryParams);
        return results;
      } else {
        // For INSERT, UPDATE, DELETE queries, execute and return info
        const stmt = client.prepare(singleQuery);
        const result = stmt.run(...queryParams);
        
        // Return standardized result info
        return [{
          changes: result.changes,
          lastInsertRowid: result.lastInsertRowid
        }];
      }
    }
    
  } catch (error) {
    // If table doesn't exist for SELECT, return empty array
    if (error instanceof Error && error.message.includes('no such table') && query.trim().toUpperCase().startsWith('SELECT')) {
      return [];
    }
    throw error;
  }
}

/**
 * Generates a CREATE TABLE SQL string for the specified table and fields
 * @param model The model definition
 * @param dbType Database type (for compatibility, not used in SQLite)
 * @returns SQL string for creating the table
 */
export function db_migrate(model: Model, dbType: string): string {
  const sanitizedTableName = sanitizeTableName(model.name);
  
  // Start with the model's fields
  let fields = [...model.fields];
  
  // Add userid field if data is user specific
  if (model.data_is_user_specific === "true") {
    fields.push({
      name: 'userid',
      datatype: 'TEXT',
      datatypesize: null,
      key: 'foreign',
      required: 'true',
      default: undefined
    });
  }
  
  // Map SQL data types for SQLite
  const sqlTypeMap: { [key: string]: string } = {
    'UUID': 'TEXT',
    'TINYINT': 'INTEGER',
    'SMALLINT': 'INTEGER',
    'BIGINT': 'INTEGER', 
    'INT128': 'TEXT',
    'VARCHAR': 'TEXT',
    'TEXT': 'TEXT',
    'BINARY': 'BLOB',
    'DATE': 'TEXT',
    'TIME': 'TEXT',
    'DATETIME': 'TEXT',
    'DOUBLE': 'REAL',
    'FLOAT': 'REAL',
    'BOOLEAN': 'INTEGER'
  };

  // Build column definitions
  const columnDefs = fields.sort((a, b) => (b.key === 'primary' ? 1 : 0) - (a.key === 'primary' ? 1 : 0)).map(field => {
    let def = `"${field.name}" ${sqlTypeMap[field.datatype.toUpperCase()]}`;
    
    // Add NOT NULL if required
    if (field.required === "true") {
        def += ' NOT NULL';
    }

    // Add default if specified
    if (field.default !== undefined) {
      if (field.datatype === 'VARCHAR' || field.datatype === 'TEXT') {
        def += ` DEFAULT '${field.default}'`;
      } else {
        def += ` DEFAULT ${field.default}`;
      }
    }

    // Add primary key constraint
    if (field.key === 'primary') {
      def += ' PRIMARY KEY';
    }
    
    return def;
  }).join(',\n  ');

  // Build the CREATE TABLE statement
  const sql = `CREATE TABLE IF NOT EXISTS "${sanitizedTableName}" (\n  ${columnDefs}\n);`;

  return sql;
}

/**
 * Close a specific database connection or all connections
 * @param dbPath Optional path to close a specific database connection. 
 *               If not provided, closes all connections.
 */
export function closeDatabase(dbPath?: string): void {
  if (!dbPath) {
    // Close all file-based connections
    for (const [path, connection] of dbConnections.entries()) {
      connection.close();
    }
    dbConnections.clear();
  } else {
    // Close specific database connection
    const connection = dbConnections.get(dbPath);
    if (connection) {
      connection.close();
      dbConnections.delete(dbPath);
    }
  }
} 

/**
 * Get or create a database connection for the specified path
 * This is a convenience wrapper for working with arbitrary database files
 * Note: For the main application database, use db_init() instead
 * @param dbPath Path to the database file (including database name)
 * @returns Database client ready for use
 */
export async function getDatabase(dbPath: string): Promise<Database.Database> {
  // Check if we already have a connection to this database
  const existingConnection = dbConnections.get(dbPath);
  if (existingConnection) {
    return existingConnection;
  }

  try {
    // Ensure the directory exists
    const dir = path.dirname(dbPath);
    if (dir && dir !== '.' && dir !== '/') {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Create database connection
    const newDb = new Database(dbPath);
    newDb.pragma('foreign_keys = ON');
    dbConnections.set(dbPath, newDb);
    
    return newDb;
  } catch (error) {
    throw error;
  }
}

/**
 * Check if a database file exists at the specified path
 * @param dbPath Path to the database file
 * @returns true if the database file exists, false otherwise
 */
export function databaseExists(dbPath: string): boolean {
  try {
    return fs.existsSync(dbPath);
  } catch (error) {
    return false;
  }
}

/**
 * Get information about the database at the specified path
 * @param dbPath Path to the database file
 * @returns Object with database information or null if database doesn't exist
 */
export async function getDatabaseInfo(dbPath: string): Promise<{
  exists: boolean;
  tables?: string[];
  size?: number;
} | null> {
  const exists = databaseExists(dbPath);
  
  if (!exists) {
    return { exists: false };
  }
  
  try {
    const stats = fs.statSync(dbPath);
    const client = await getDatabase(dbPath);
    
    // Get list of tables
    const tables = await db_query(
      client, 
      "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
    );
    
    return {
      exists: true,
      tables: tables.map(t => t.name),
      size: stats.size
    };
  } catch (error) {
    return null;
  }
}
